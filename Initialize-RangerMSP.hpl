<?xml version="1.0" encoding="UTF-8"?>
<pipeline>
  <info>
    <name>Initialize-RangerMSP</name>
    <name_sync_with_filename>Y</name_sync_with_filename>
    <description/>
    <extended_description/>
    <pipeline_version/>
    <pipeline_type>Normal</pipeline_type>
    <pipeline_status>0</pipeline_status>
    <parameters>
    </parameters>
    <capture_transform_performance>N</capture_transform_performance>
    <transform_performance_capturing_delay>1000</transform_performance_capturing_delay>
    <transform_performance_capturing_size_limit>100</transform_performance_capturing_size_limit>
    <created_user>-</created_user>
    <created_date>2019/12/30 23:07:41.770</created_date>
    <modified_user>admin</modified_user>
    <modified_date>2020/01/04 18:00:08.547</modified_date>
    <key_for_session_key>H4sIAAAAAAAAAAMAAAAAAAAAAAA=</key_for_session_key>
    <is_key_private>N</is_key_private>
  </info>
  <notepads>
  </notepads>
  <order>
    <hop>
      <from>Query Ticketcategories from RangerMSP</from>
      <to>Create :Ticketcategory nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Update Assetcategory from assets</from>
      <to>Create new distinct Assetcategory nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Update Manufacturer from assets</from>
      <to>Create new distinct Manufacturer nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Query DISTINCT (:Crmcontractpayment) nodes</from>
      <to>CREATE DISTINCT (:Crmcontractpayment) nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Query DISTINCT (:Crmprojectstatus) nodes</from>
      <to>CREATE DISTINCT (:Crmcontractstatus) nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Update :Ticketlabel nodes from Labels </from>
      <to>Create new :Ticketlabel nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>UpdateOppstage from opps</from>
      <to>Create new distinct Oppstage nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>UpdateOppkind from opps</from>
      <to>Create new distinct Oppkind nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Update Oppreason from opps</from>
      <to>Create new distinct Oppreason nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Update Oppsource from opps</from>
      <to>Create new distinct Oppsource nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Get variables</from>
      <to>Update Logging (RangerMSP update tf start)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Ingest Public Domains</from>
      <to>Collect Public Domains</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Query DISTINCT (:Itemclass) nodes</from>
      <to>CREATE DISTINCT (:Itemclass) nodes</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Query :Ticketstatus from RangerMSP</from>
      <to>Create (:Ticketstatus) Labels</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Query :Ticketpriority from RangerMSP</from>
      <to>Create (:Ticketpriority) Labels</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Query Contract Types from RangerMSP</from>
      <to>ContractTypes</to>
      <enabled>Y</enabled>
    </hop>
  </order>
  <transform>
    <name>CREATE DISTINCT (:Crmcontractpayment) nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $payments as p
MERGE (cps:Crmcontractpayment {name:p.user1})
;</cypher>
    <batch_size>500</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>payments</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>user1</parameter>
        <field>user1</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>160</yloc>
    </GUI>
  </transform>
  <transform>
    <name>CREATE DISTINCT (:Crmcontractstatus) nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $projstatus as p
MERGE (ps:Crmprojectstatus {name:p.user3})
;</cypher>
    <batch_size>500</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>projstatus</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>user3</parameter>
        <field>user3</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>224</yloc>
    </GUI>
  </transform>
  <transform>
    <name>CREATE DISTINCT (:Itemclass) nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $ic as i
WITH * WHERE i.user1 IS NOT NULL
MERGE (:Itemclass {name:i.user1})
RETURN i.user1
;</cypher>
    <batch_size>500</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>ic</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>user1</parameter>
        <field>user1</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>i.user1</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>496</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Collect Public Domains</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $pubdomains as d
WITH * WHERE not d.domain='Domain'
WITH COLLECT(distinct toLower(d.domain)) as domains,max(d.row) as row
WITH apoc.text.join(domains,',') as domains,row
MERGE (p:Publicdomains {id:row})
SET p.names=split(domains,',')
RETURN domains,row</cypher>
    <batch_size>500</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>pubdomains</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>domain</parameter>
        <field>domain</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>row</parameter>
        <field>row</field>
        <type>Integer</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>560</yloc>
    </GUI>
  </transform>
  <transform>
    <name>ContractTypes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $ctypes as c
WITH * WHERE c.name='Block of Money' or c.name='Block of Tickets' or c.name='Block of Time' or c.name = 'IT Project (Time &amp; Material)'
MERGE (gc:Crmcontracttype {recid:c.recid})
SET gc.name=c.name,gc.value=c.value,gc.project=c.project
SET gc.default=true
RETURN count(gc) AS contracttypes
;
</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>ctypes</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>recid</parameter>
        <field>RECID</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>name</parameter>
        <field>NAME</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>contracttype</parameter>
        <field>CONTRACTTYPE</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>project</parameter>
        <field>PROJECT</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>96</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create (:Ticketpriority) Labels</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $priority as p
MERGE (tp:Ticketpriority {token:p.token})
FOREACH (ignoreMe in CASE WHEN p.value IS NOT NULL and p.value &lt;&gt; '' THEN [1] ELSE [] END | SET tp.value=trim(p.value))
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_IMMEDIATE' and(tp.value = "" or tp.value is null) THEN [1] ELSE [] END | SET tp.name='Immediate',tp.statcode=10)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_IMMEDIATE' and tp.value &lt;&gt; "" THEN [1] ELSE [] END | SET tp.name=tp.value,tp.statcode=10)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_HIGHT' and(tp.value = "" or tp.value is null) THEN [1] ELSE [] END | SET tp.name='High',tp.statcode=20)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_HIGHT' and tp.value &lt;&gt; "" THEN [1] ELSE [] END | SET tp.name=tp.value,tp.statcode=20)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_NORMAL' and(tp.value = "" or tp.value is null) THEN [1] ELSE [] END | SET tp.name='Normal',tp.statcode=30)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_NORMAL' and tp.value &lt;&gt; "" THEN [1] ELSE [] END | SET tp.name=tp.value,tp.statcode=30)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_LOW' and(tp.value = "" or tp.value is null) THEN [1] ELSE [] END | SET tp.name='Low',tp.statcode=40)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_LOW' and tp.value &lt;&gt; "" THEN [1] ELSE [] END | SET tp.name=tp.value,tp.statcode=40)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_NONE' and(tp.value = "" or tp.value is null) THEN [1] ELSE [] END | SET tp.name='None',tp.statcode=50)
FOREACH (ignoreMe in CASE WHEN tp.token='TKT_PRIORITY_NONE' and tp.value &lt;&gt; "" THEN [1] ELSE [] END | SET tp.name=tp.value,tp.statcode=50)
RETURN count(tp) as ticketprioritycount
;</cypher>
    <batch_size>500</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>priority</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>token</parameter>
        <field>token</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>value</parameter>
        <field>value</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>352</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create (:Ticketstatus) Labels</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $status as s
MERGE (ts:Ticketstatus {token:s.token})
FOREACH (ignoreMe in CASE WHEN s.value IS NOT NULL AND s.value &lt;&gt; '' THEN [1] ELSE [] END | SET ts.value=s.value)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_INCOME' and ts.value is null THEN [1] ELSE [] END | SET ts.name='New',ts.statcode=100)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_INCOME' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=100)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_SCHEDNEEDED' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Pending',ts.statcode=200)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_SCHEDNEEDED' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=200)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_SCHEDED' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Scheduled',ts.statcode=300)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_SCHEDED' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=300)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_IN_OFFICE' and ts.value is null THEN [1] ELSE [] END | SET ts.name='In-House Service',ts.statcode=400)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_IN_OFFICE' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=400)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_IN_LOCATION' and ts.value is null THEN [1] ELSE [] END | SET ts.name='On-site Service',ts.statcode=500)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_IN_LOCATION' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=500)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_IN_LABORATORY' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Laboratory Service',ts.statcode=600)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_IN_LABORATORY' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=600)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_HOLD' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Hold',ts.statcode=700)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_HOLD' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=700)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_OTHER' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Other',ts.statcode=800)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_OTHER' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=800)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_CANCELED' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Cancelled',ts.statcode=900)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_CANCELED' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=900)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_COMPLETED' and ts.value is null THEN [1] ELSE [] END | SET ts.name='Completed',ts.statcode=1000)
FOREACH (ignoreMe in CASE WHEN ts.token='TKT_STATUS_COMPLETED' and ts.value is not null THEN [1] ELSE [] END | SET ts.name=ts.value,ts.statcode=1000)
RETURN count(ts) as ticketstatuscount
;

</cypher>
    <batch_size>500</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>status</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>token</parameter>
        <field>token</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>value</parameter>
        <field>value</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>288</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create :Ticketcategory nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $categories as c
MERGE (t:Ticketcategory {name: c.CATEGORY})
RETURN c.CATEGORY as category
;
</cypher>
    <batch_size>25</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>categories</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>CATEGORY</parameter>
        <field>CATEGORY</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>category</name>
        <type>String</type>
        <source_type/>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>32</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new :Ticketlabel nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $labels as l
MERGE (tl:Ticketlabel {labelcode:l.intvalue}) SET tl.name=l.name
RETURN l.name
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>labels</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>intvalue</parameter>
        <field>intvalue</field>
        <type>Integer</type>
      </mapping>
      <mapping>
        <parameter>name</parameter>
        <field>name</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>l.name</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>1072</xloc>
      <yloc>416</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new distinct Assetcategory nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $categories as c
WITH COLLECT(distinct c.user1) as categories
UNWIND categories as cat
MERGE (ac:Assetcategory {name:cat})
;</cypher>
    <batch_size>25000</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>categories</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>user1</parameter>
        <field>user1</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>badasset</name>
        <type>String</type>
        <source_type/>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>112</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new distinct Manufacturer nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $manufacturers as m
WITH COLLECT(distinct m.manufacturer) as manufacturers,"[^a-zA-Z\\d]" as regex
UNWIND manufacturers as mfr
OPTIONAL MATCH (m:Manufacturer) where toLower(m.name)=trim(toLower(mfr)) or toLower(m.name) in m.aliases
WITH * where m is null
MERGE (:Manufacturer {name:mfr})
;</cypher>
    <batch_size>25000</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>manufacturers</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>manufacturer</parameter>
        <field>manufacturer</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>176</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new distinct Oppkind nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $kinds as k
MERGE (ok:Oppkind {name:k.kind})
RETURN k.kind as kind
;</cypher>
    <batch_size>25000</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>kinds</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>kind</parameter>
        <field>kind</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>kind</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>368</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new distinct Oppreason nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $reasons as r
MERGE (or:Oppreason {name:r.reason})
RETURN r.reason as reason
;</cypher>
    <batch_size>25000</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>reasons</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>reason</parameter>
        <field>reason</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>reason</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>432</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new distinct Oppsource nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $sources as s
MERGE (os:Oppsource {name:s.source})
RETURN s.source as source
;</cypher>
    <batch_size>25000</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>sources</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>source</parameter>
        <field>source</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>source</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>496</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Create new distinct Oppstage nodes</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $stages as s
WITH Tointeger(SPLIT(s.value,' ')[0]) as stageid,replace(s.value,left(s.value,3),'') as stagename
MERGE (os:Oppstage {id:stageid}) SET os.name=stagename
RETURN stageid,stagename
;</cypher>
    <batch_size>25000</batch_size>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>stages</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>value</parameter>
        <field>value</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>stageid</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
      <return>
        <name>stagename</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>240</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Get variables</name>
    <type>GetVariable</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <fields>
      <field>
        <name>jobname</name>
        <variable> ${Internal.Workflow.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>transname</name>
        <variable>${Internal.Pipeline.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>tdir</name>
        <variable>${Internal.Pipeline.Filename.Folder}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>jdir</name>
        <variable>${Internal.Workflow.Filename.Folder}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>jfilename</name>
        <variable>${Internal.Workflow.Filename.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>tfilename</name>
        <variable>${Internal.Pipeline.Filename.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
    </fields>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>48</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Ingest Public Domains</name>
    <type>CSVInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <filename>${PROJECT_HOME}/../RangerMSP/ISP-email-domains.csv</filename>
    <filename_field/>
    <rownum_field>row</rownum_field>
    <include_filename>N</include_filename>
    <separator>,</separator>
    <enclosure>"</enclosure>
    <header>N</header>
    <buffer_size>50000</buffer_size>
    <lazy_conversion>N</lazy_conversion>
    <add_filename_result>N</add_filename_result>
    <parallel>N</parallel>
    <newline_possible>N</newline_possible>
    <encoding/>
    <fields>
      <field>
        <name>domain</name>
        <type>String</type>
        <format/>
        <currency>$</currency>
        <decimal>.</decimal>
        <group>,</group>
        <length>30</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
    </fields>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>560</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query :Ticketpriority from RangerMSP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT token,value from Pref where Token like '%TKT_PRIORITY%'</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>352</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query :Ticketstatus from RangerMSP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT token,value from Pref where Token like '%TKT_STATUS%'</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>288</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query Contract Types from RangerMSP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT RECID,NAME,CONTRACTTYPE,PROJECT from BPLANS WHERE STATUS='A'</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>96</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query DISTINCT (:Crmcontractpayment) nodes</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT DISTINCT user1 from bcontracts where user1 is not null</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>160</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query DISTINCT (:Crmprojectstatus) nodes</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT DISTINCT user3 from bcontracts where user3 is not null</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>224</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query DISTINCT (:Itemclass) nodes</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT DISTINCT user1 from items</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>496</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Query Ticketcategories from RangerMSP</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <limit>0</limit>
    <sql>SELECT DISTINCT CATEGORY from Tickets where CATEGORY is not null</sql>
    <variables_active>Y</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>32</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update :Ticketlabel nodes from Labels </name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT DISTINCT intvalue,name FROM Labels WHERE name is not null</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>784</xloc>
      <yloc>416</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Assetcategory from assets</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT user1 from assets where user1 is not null and user1 &lt;&gt; ''</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>112</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Logging (RangerMSP update tf start)</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $taskparams as t
WITH t,timestamp() as tfstart,trim(replace(t.jobname,'Parent Job Name',t.transname)) as jobname
MATCH (l:N4jlogging {jobname:jobname})
SET l.lasttfrun=tfstart,l.jobname=jobname,l.transname=t.transname,l.jobstatus='running',l.tdir=t.tdir,l.tfilename=t.tfilename,l.jdir=t.jdir,l.jfilename=t.jfilename
RETURN apoc.date.format(l.lastjobrun,'ms',"yyyy-MM-dd'T'HH:mm:ss",'CST') as jobstart,l.jobname
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>taskparams</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>jobname</parameter>
        <field>jobname</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>transname</parameter>
        <field>transname</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>tdir</parameter>
        <field>tdir</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>jdir</parameter>
        <field>jdir</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>jfilename</parameter>
        <field>jfilename</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>tfilename</parameter>
        <field>tfilename</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>jobstart</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>l.jobname</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>l.transname</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>384</xloc>
      <yloc>48</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Manufacturer from assets</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT manufacturer from assets where manufacturer is not null and manufacturer &lt;&gt; ''</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>176</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Oppreason from opps</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT distinct reason FROM opps WHERE reason is not null and reason &lt;&gt; ''</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>432</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Oppsource from opps</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT distinct source FROM opps WHERE source is not null and source &lt;&gt; ''</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>496</yloc>
    </GUI>
  </transform>
  <transform>
    <name>UpdateOppkind from opps</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT distinct kind FROM opps WHERE kind is not null and kind &lt;&gt; ''</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>368</yloc>
    </GUI>
  </transform>
  <transform>
    <name>UpdateOppstage from opps</name>
    <type>TableInput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${RangerMSP-ds}</connection>
    <execute_each_row>N</execute_each_row>
    <sql>SELECT value FROM valueslist WHERE TABLE_KIND=40</sql>
    <variables_active>N</variables_active>
    <attributes/>
    <GUI>
      <xloc>112</xloc>
      <yloc>240</yloc>
    </GUI>
  </transform>
  <transform_error_handling>
  </transform_error_handling>
  <attributes/>
</pipeline>
