<?xml version="1.0" encoding="UTF-8"?>
<pipeline>
  <info>
    <name>RangerMSP-ticket-automation-processing</name>
    <name_sync_with_filename>Y</name_sync_with_filename>
    <description/>
    <extended_description/>
    <pipeline_version/>
    <pipeline_type>Normal</pipeline_type>
    <parameters>
    </parameters>
    <capture_transform_performance>N</capture_transform_performance>
    <transform_performance_capturing_delay>1000</transform_performance_capturing_delay>
    <transform_performance_capturing_size_limit>100</transform_performance_capturing_size_limit>
    <created_user>-</created_user>
    <created_date>2020/10/24 08:36:31.304</created_date>
    <modified_user>-</modified_user>
    <modified_date>2020/10/24 08:36:31.304</modified_date>
    <key_for_session_key>H4sIAAAAAAAAAAMAAAAAAAAAAAA=</key_for_session_key>
    <is_key_private>N</is_key_private>
  </info>
  <notepads>
  </notepads>
  <order>
    <hop>
      <from>Find automation tickets that are assigned to manager</from>
      <to>Update Tickets Table</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find cmk tickets that should be closed</from>
      <to>Close Tickets (CMK)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows</from>
      <to>Find cmk tickets that should be closed</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find cmk tickets that should be "Please Review"</from>
      <to>Please Review Tickets (cmk)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows 2</from>
      <to>Find cmk tickets that should be "Please Review"</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows</from>
      <to>Find Datto tickets that should be closed</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows 2</from>
      <to>Find Datto tickets that should be "Please Review"</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find Datto tickets that should be closed</from>
      <to>Close Tickets (Datto)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find Datto tickets that should be "Please Review"</from>
      <to>Please Review Tickets (datto)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find NinjaRMM (provisioning) tickets that should be closed</from>
      <to>Close Tickets (Ninja Provisioning) </to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows</from>
      <to>Find NinjaRMM (provisioning) tickets that should be closed</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find NinjaRMM (patching) tickets that should be closed</from>
      <to>Close Tickets (Ninja Patching)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows</from>
      <to>Find NinjaRMM (patching) tickets that should be closed</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Get job variables</from>
      <to>Update Job/TFLogging</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Find ophan user tickets that should be closed</from>
      <to>Close Tickets (orphaned users)</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Generate rows</from>
      <to>Find ophan user tickets that should be closed</to>
      <enabled>Y</enabled>
    </hop>
  </order>
  <transform>
    <name>Auto-close auto-created tickets that check_mk no longer reporting a warn/crit/unknown servicestate</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (cmkh:Cmkhost)-[:HAS_SERVICE]-(cmks:Cmkservice)-[:HAS_TICKET]-(t:Ticket)-[tsr:TICKET_STATUS]-(ts:Ticketstatus) where not((cmks)-[:IN_STATE]-(:Servicestate)) and (t)-[:PART_OF_TICKET]-(:Crmcharge) and ts.statcode&lt;900
WITH * WHERE not ((cmks)-[:PROBLEM_ACKNOWLEDGEMENT]-(:Problemack {name:'Unacknowledged'})) and ((cmks.servicestateage contains 'm' and toInteger(split(cmks.servicestateage,' ')[0]) > 10) or not (cmks.servicestateage contains 's' or  cmks.servicestateage contains 'm'))
return t.recid as ticketid
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>ticketid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>816</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Close Tickets (CMK)</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>closetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>USER3</name>
        <rename>Automation</rename>
      </value>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>CLOSEDATETIME</name>
        <rename>closedate</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>closedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>16</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Close Tickets (Datto)</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>closetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>USER3</name>
        <rename>Automation</rename>
      </value>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>CLOSEDATETIME</name>
        <rename>closedate</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>closedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>144</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Close Tickets (Ninja Patching)</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>closetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>USER3</name>
        <rename>Automation</rename>
      </value>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>CLOSEDATETIME</name>
        <rename>closedate</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>closedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>272</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Close Tickets (Ninja Provisioning) </name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>closetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>USER3</name>
        <rename>Automation</rename>
      </value>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>CLOSEDATETIME</name>
        <rename>closedate</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>closedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>208</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Close Tickets (orphaned users)</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>closetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>USER3</name>
        <rename>Automation</rename>
      </value>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>CLOSEDATETIME</name>
        <rename>closedate</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>closedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>80</yloc>
    </GUI>
  </transform>
  <transform>
    <name>DELETE automation ticket relationships from closed tickets</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (x)-[htr:HAS_TICKET]-(t:Ticket)-[:TICKET_STATUS]-(ts:Ticketstatus) where ts.statcode >=900 and ((t.pendingautoclose&lt;&gt;true) or t.pendingautoclose IS NULL)
OPTIONAL MATCH (t)-[:QUEUE_FOR_TICKET]-(tq:Ticketqueue)
FOREACH (ignoreMe in CASE WHEN tq.status IS NOT NULL THEN [1] ELSE [] END | SET tq.status='closed')
DELETE htr
;
</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>464</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find Datto tickets that should be "Please Review"</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue)-[:QUEUE_FOR_TICKET]-(t:Ticket {source:'Datto API'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) 
where ts.statcode&lt;800 and t.automation = 'Do not Autoclose' and t.manager = 'Check_MK'
MATCH (tq)-[:QUEUE_FOR_SERVICE]-(da:Dattoasset {guid:tq.guid})
MATCH (da)-[:LAST_BACKUP_SUCCESS]-(lgb:Lastgoodbackup) where lgb.delta &lt; 86400000 and lgb.delta&lt;&gt;0
MATCH (da)-[:LAST_VERIFICATION_SUCCESS]-(lgv:Lastgoodbackup) where lgv.delta &lt; 86400000 and lgv.delta&lt;&gt;0
MATCH (da)-[:LAST_SCREENSHOT_SUCCESS]-(lgs:Lastgoodbackup) where lgs.delta &lt; 86400000 and lgs.delta &lt;&gt; 0
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as updatedate
SET t.status=800
RETURN t.recid as updatetrecid,t.host as updatehost,t.service as updateservice,t.automation as Automation,t.status as Status,t.manager,updatedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>updatetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>updatehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>updateservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>updatedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>ticketnumber</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
      <return>
        <name>updatedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>400</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find Datto tickets that should be closed</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue {source:'Datto API'})-[:QUEUE_FOR_TICKET]-(t:Ticket {source:'Datto API'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) 
where ts.statcode&lt;900 and ((t.automation = 'Review and Autoclose' and t.manager &lt;&gt; 'Check_MK') or (t.automation = 'Review and Autoclose(AQ)' and t.manager = 'Check_MK') )
MATCH (tq)-[:QUEUE_FOR_SERVICE]-(da:Dattoasset {guid:tq.guid})
MATCH (da)-[:LAST_BACKUP_SUCCESS]-(lgb:Lastgoodbackup) where lgb.delta &lt; 86400000 and lgb.delta&lt;&gt;0
MATCH (da)-[:LAST_VERIFICATION_SUCCESS]-(lgv:Lastgoodbackup) where lgv.delta &lt; 86400000 and lgv.delta&lt;&gt;0
MATCH (da)-[:LAST_SCREENSHOT_SUCCESS]-(lgs:Lastgoodbackup) where lgs.delta &lt; 86400000 and lgs.delta &lt;&gt; 0
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as closedate
SET t.status=1000,t.automation='Closed (by automation)'
RETURN t.recid as closetrecid,t.host as closehost,t.service as closeservice,t.automation as Automation,t.status as Status,t.manager,closedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>closetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closeservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>144</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find NinjaRMM (patching) tickets that should be closed</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue {service:'NinjaRMM Patching'})-[:QUEUE_FOR_TICKET]-(t:Ticket {source:'BlueGraph Automation'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) 
where ts.statcode&lt;900 and ((t.automation = 'Review and Autoclose' and t.manager &lt;&gt; 'Check_MK') or (t.automation = 'Review and Autoclose(AQ)' and t.manager = 'Check_MK') )
MATCH (ca:Crmasset {recid:tq.asset})-[]-(r:Rmmdevice)
OPTIONAL MATCH (r)-[pr:FAILED_PATCH_STATUS]-(:Rmmpatch)
WITH * WHERE pr.status IS NULL and (r)-[:INSTALLED_PATCH_STATUS]-(:Rmmpatch)
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as closedate
SET t.status=1000,t.automation='Closed (by automation)'
RETURN t.recid as closetrecid,t.host as closehost,t.service as closeservice,t.automation as Automation,t.status as Status,t.manager,closedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>closetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closeservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>272</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find NinjaRMM (provisioning) tickets that should be closed</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue {service:'NinjaRMM Provisioning'})-[:QUEUE_FOR_TICKET]-(t:Ticket {source:'BlueGraph Automation'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) 
where ts.statcode&lt;900 and ((t.automation = 'Review and Autoclose' and t.manager &lt;&gt; 'Check_MK') or (t.automation = 'Review and Autoclose(AQ)' and t.manager = 'Check_MK') )
MATCH (r:Rmmdevice)-[:BELONGS_TO_ORG]-(o:Ninjaorg) WHERE r.name=tq.host or r.dnsname=tq.host
WITH t,tq WHERE (NOT (r)-[:BELONGS_TO_ORG]-(:Ninjaorg {id:34}) AND NOT (r)-[:BELONGS_TO_ORG]-(:Ninjaorg {id:39})) or ((r)-[:BELONGS_TO_ORG]-(o) AND o.id&lt;&gt;34 AND o.id&lt;&gt;34)
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as closedate
SET t.status=1000,t.automation='Closed (by automation)'
RETURN t.recid as closetrecid,t.host as closehost,t.service as closeservice,t.automation as Automation,t.status as Status,t.manager,closedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>closetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closeservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>208</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find automation tickets that are assigned to manager</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>WITH 'Do not Autoclose' as autoclose
MATCH (x)-[:HAS_TICKET]-(t:Ticket {automation:'Review and Autoclose(AQ)'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) where  ts.statcode&lt;900 and t.manager &lt;&gt; 'Check_MK'
SET t.automation='Do not Autoclose'
RETURN t.recid as trecid,autoclose
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>trecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>autoclose</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>176</xloc>
      <yloc>720</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find cmk tickets that should be "Please Review"</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (a:Company)-[:TICKET_OF_CLIENT]-(t:Ticket {source:'noc.bluenetcloud.com'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) where ts.statcode&lt;800 and t.automation = 'Do not Autoclose' and t.manager = 'Check_MK'
OPTIONAL MATCH (tq:Ticketqueue)-[:QUEUE_FOR_TICKET]-(t)
OPTIONAL MATCH (ch:Cmkhost)-[:TAGGED_WITH]-(:Cmkhosttag)-[:ASSIGNS_HOSTS_TO]-(:Cmkhostgroup)-[:BELONGS_TO]-(a) WHERE left(ch.name,30)=t.host or ch.name=tq.host
OPTIONAL MATCH (ch)-[:HAS_SERVICE]-(cs:Cmkservice {name:coalesce(tq.service,t.service)})-[:IN_STATE]-(ss:Servicestate)
OPTIONAL MATCH (ch)-[:IN_STATE]-(hs:Hoststate {name:'Down'})
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as updatedate where ( cs.name is null or cs.unverified=true or ss.name IS NULL) AND (hs.name IS NULL or ch.name IS NULL)
SET t.status=800
RETURN t.recid as updatetrecid,t.host as updatehost,t.service as updateservice,t.automation as Automation,t.status as Status,t.manager,updatedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>updatetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>updatehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>updateservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>updatedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>ticketnumber</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
      <return>
        <name>updatedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>336</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find cmk tickets that should be closed</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (a:Company)-[:TICKET_OF_CLIENT]-(t:Ticket {source:'noc.bluenetcloud.com'})-[tsr:TICKET_STATUS]-(ts:Ticketstatus) where ts.statcode&lt;900 and ((t.automation = 'Review and Autoclose' and t.manager &lt;&gt; 'Check_MK') or (t.automation = 'Review and Autoclose(AQ)' and t.manager = 'Check_MK') )
OPTIONAL MATCH (tq:Ticketqueue)-[:QUEUE_FOR_TICKET]-(t)
OPTIONAL MATCH (ch:Cmkhost)-[:TAGGED_WITH]-(:Cmkhosttag)-[:ASSIGNS_HOSTS_TO]-(:Cmkhostgroup)-[:BELONGS_TO]-(a) WHERE left(ch.name,30)=t.host or ch.name=tq.host
OPTIONAL MATCH (ch)-[:HAS_SERVICE]-(cs:Cmkservice {name:coalesce(tq.service,t.service)})-[:IN_STATE]-(ss:Servicestate)
OPTIONAL MATCH (ch)-[:IN_STATE]-(hs:Hoststate {name:'Down'})
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as closedate where (cs.name is null or cs.unverified=true or ss.name IS NULL) AND (hs.name IS NULL or ch.name IS NULL)
SET t.status=1000,t.automation='Closed (by automation)'
RETURN t.recid as closetrecid,t.host as closehost,t.service as closeservice,t.automation as Automation,t.status as Status,t.manager,closedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>closetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closeservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>16</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Find ophan user tickets that should be closed</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (t:Ticket {host:'Orphaned New User'})-[:TICKET_STATUS]-(ts:Ticketstatus)
where ts.statcode&lt;900 and ((t.automation = 'Review and Autoclose' and t.manager &lt;&gt; 'Check_MK') or (t.automation = 'Review and Autoclose(AQ)' and t.manager = 'Check_MK') )
MATCH (t:Ticket)-[:TICKET_OF_CLIENT]-(a:Company)
MATCH (rc:Reportingcontact {company:a.name})-[:USER_MODIFICATION_TICKET]-(mt:Ticket) WHERE left(rc.upn,30)=left(t.service,30) //LEFT 30 because RangerMSP field is limited to 30 chars
WITH *,apoc.date.format(timestamp(),'ms','yyyy-MM-dd HH:mm:ss.sss','CST') as closedate
SET t.status=1000,t.automation='Closed (by automation)'
RETURN t.recid as closetrecid,t.host as closehost,t.service as closeservice,t.automation as Automation,t.status as Status,t.manager,closedate</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>closetrecid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closehost</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closeservice</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Automation</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>t.manager</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>closedate</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>Status</name>
        <type>Integer</type>
        <source_type>Integer</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>288</xloc>
      <yloc>80</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Generate rows</name>
    <type>RowGenerator</type>
    <description/>
    <distribute>N</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <fields>
      <field>
        <length>-1</length>
        <name>Automation</name>
        <precision>-1</precision>
        <set_empty_string>N</set_empty_string>
        <type>String</type>
        <nullif>Closed (by automation)</nullif>
      </field>
      <field>
        <length>-1</length>
        <name>Status</name>
        <precision>-1</precision>
        <set_empty_string>N</set_empty_string>
        <type>Integer</type>
        <nullif>1000</nullif>
      </field>
    </fields>
    <interval_in_ms>5000</interval_in_ms>
    <last_time_field>FiveSecondsAgo</last_time_field>
    <never_ending>N</never_ending>
    <limit>1</limit>
    <row_time_field>now</row_time_field>
    <attributes/>
    <GUI>
      <xloc>48</xloc>
      <yloc>16</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Generate rows 2</name>
    <type>RowGenerator</type>
    <description/>
    <distribute>N</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <fields>
      <field>
        <length>-1</length>
        <name>Status</name>
        <precision>-1</precision>
        <set_empty_string>N</set_empty_string>
        <type>Integer</type>
        <nullif>800</nullif>
      </field>
    </fields>
    <interval_in_ms>5000</interval_in_ms>
    <last_time_field>FiveSecondsAgo</last_time_field>
    <never_ending>N</never_ending>
    <limit>1</limit>
    <row_time_field>now</row_time_field>
    <attributes/>
    <GUI>
      <xloc>48</xloc>
      <yloc>352</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Get job variables</name>
    <type>GetVariable</type>
    <description/>
    <distribute>N</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <fields>
      <field>
        <name>jobname</name>
        <variable> ${Internal.Workflow.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>transname</name>
        <variable>${Internal.Pipeline.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>tdir</name>
        <variable>${Internal.Pipeline.Filename.Folder}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>jdir</name>
        <variable>${Internal.Workflow.Filename.Folder}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>jfilename</name>
        <variable>${Internal.Workflow.Filename.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
      <field>
        <name>tfilename</name>
        <variable>${Internal.Pipeline.Filename.Name}</variable>
        <type>String</type>
        <format/>
        <currency/>
        <decimal/>
        <group/>
        <length>-1</length>
        <precision>-1</precision>
        <trim_type>none</trim_type>
      </field>
    </fields>
    <attributes/>
    <GUI>
      <xloc>48</xloc>
      <yloc>528</yloc>
    </GUI>
  </transform>
  <transform>
    <name>MERGE tickets with the Check_MK Service (recid)</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue)-[:QUEUE_FOR_SERVICE]-(x) where not (:Ticket)&lt;-[:HAS_TICKET]-(x) AND tq.trecid IS NOT NULL
MATCH (t:Ticket {recid:tq.trecid})
MERGE (t)&lt;-[:HAS_TICKET]-(x)
FOREACH (ignoreMe in CASE WHEN tq.status &lt;&gt; 'subticket' THEN [1] ELSE [] END | SET tq.status='linked')
return x.name as service,t.recid as recid,tq.status as status
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns>
      <return>
        <name>service</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>recid</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>status</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>608</xloc>
      <yloc>720</yloc>
    </GUI>
  </transform>
  <transform>
    <name>MERGE tickets with the Service or object (tnumber)</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue)-[:QUEUE_FOR_SERVICE]-(x) where tq.tnumber IS NOT NULL
WITH *,replace(tq.tnumber,'0500-','0500-00000') as fulltnumber
MATCH (t:Ticket) where t.ticketnumber=fulltnumber
MERGE (t)&lt;-[:HAS_TICKET]-(x)
set tq.status='linked'
;
</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>896</xloc>
      <yloc>720</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Please Review Tickets (cmk)</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>updatetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>updatedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>336</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Please Review Tickets (datto)</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>updatetrecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>STATUS</name>
        <rename>Status</rename>
      </value>
      <value>
        <name>UPDATEDATE</name>
        <rename>updatedate</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>544</xloc>
      <yloc>400</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Set tq status to closed for any TQ items with closed tickets.</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>MATCH (tq:Ticketqueue)-[:QUEUE_FOR_TICKET]-(t:Ticket)-[tsr:TICKET_STATUS]-(ts:Ticketstatus) WHERE ts.statcode >=900
SET tq.status='closed'
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>N</unwind>
    <unwind_map/>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings/>
    <returns/>
    <attributes/>
    <GUI>
      <xloc>672</xloc>
      <yloc>464</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Job/TFLogging</name>
    <type>Neo4jCypherOutput</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <connection>${graphdb-ds}</connection>
    <cypher>UNWIND $taskparams as t
WITH t,timestamp() as tfstart,trim(replace(t.jobname,'Parent Job Name',t.transname)) as jobname
MATCH (l:N4jlogging {jobname:jobname})
SET l.lasttfrun=tfstart,l.jobname=jobname,l.transname=t.transname,l.jobstatus='running',l.tdir=t.tdir,l.tfilename=t.tfilename,l.jdir=t.jdir,l.jfilename=t.jfilename
RETURN apoc.date.format(l.lastjobrun,'ms',"yyyy-MM-dd'T'HH:mm:ss",'CST') as jobstart,l.jobname
;</cypher>
    <batch_size/>
    <read_only>N</read_only>
    <nr_retries_on_error/>
    <retry>Y</retry>
    <cypher_from_field>N</cypher_from_field>
    <cypher_field/>
    <unwind>Y</unwind>
    <unwind_map>taskparams</unwind_map>
    <returning_graph>N</returning_graph>
    <return_graph_field/>
    <mappings>
      <mapping>
        <parameter>jobname</parameter>
        <field>jobname</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>transname</parameter>
        <field>transname</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>tdir</parameter>
        <field>tdir</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>jdir</parameter>
        <field>jdir</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>jfilename</parameter>
        <field>jfilename</field>
        <type>String</type>
      </mapping>
      <mapping>
        <parameter>tfilename</parameter>
        <field>tfilename</field>
        <type>String</type>
      </mapping>
    </mappings>
    <returns>
      <return>
        <name>jobstart</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>l.jobname</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
      <return>
        <name>l.transname</name>
        <type>String</type>
        <source_type>String</source_type>
      </return>
    </returns>
    <attributes/>
    <GUI>
      <xloc>176</xloc>
      <yloc>528</yloc>
    </GUI>
  </transform>
  <transform>
    <name>Update Tickets Table</name>
    <type>Update</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <commit>100</commit>
    <connection>${RangerMSP-ds}</connection>
    <error_ignored>N</error_ignored>
    <lookup>
      <key>
        <condition>=</condition>
        <field>RECID</field>
        <name>trecid</name>
      </key>
      <schema>//edc-commitcrm.tdonline.com/CommitCRM/Db</schema>
      <table>Tickets.adt</table>
      <value>
        <name>USER3</name>
        <rename>autoclose</rename>
      </value>
    </lookup>
    <skip_lookup>N</skip_lookup>
    <use_batch>N</use_batch>
    <attributes/>
    <GUI>
      <xloc>400</xloc>
      <yloc>720</yloc>
    </GUI>
  </transform>
  <transform_error_handling>
  </transform_error_handling>
  <attributes/>
</pipeline>
